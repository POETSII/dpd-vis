<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="d3-3d.js"></script>
<body>


<form name="filter_input">
     <input value="Filter"  type="button" onclick="filterBeads()" >
     <input type="text" id="filter_id" placeholder="particle ID to filter&hellip;">
</form>

<p id="cur_filters_text">  </p>

<form name="filter_input">
     <input value="Replay"  type="button" onclick="replayFrames()" >
     <input type="text" id="replay_framerate" placeholder="framerate">
</form>

<svg width="800" height="800"></svg>
<script>
    // -----------------------------------------------
    //     edit these parameters
    // -----------------------------------------------
    var outHeight = 800; // size of the displayed image (square outHeight x outHeight)
    var simSize = 75.0; // size of the simulation simSize x simSize
    var beadSize = 3; // size of each rendered bead
    var frameDelay = 1; // How many miliseconds to wait between frame playback
    // -----------------------------------------------

    var color   = d3.scaleOrdinal(d3.schemeCategory10);
    var sPos    = d3.scaleLinear().domain([0.0,simSize]).range([0,outHeight]);
    var svg     = d3.select('svg');

    // global variable for tracking if we are in a replay mode
    var replay = false;

    function getNewData(jsonfile) {
        p_pos = [];
        var request = new XMLHttpRequest();
        request.open("GET", jsonfile, false);
        request.send(null)
        var JSON_object = JSON.parse(request.responseText);
        var particles = JSON_object.beads;
        return particles;
    }

    function updateFrame(datain){
        //svg.selectAll('circle').remove();
        svg.selectAll("*").remove();
        var circles = svg.selectAll("circle")
                         .data(datain)
                         .enter()
                         .append("circle")
                         .attr("cx", function(d) { return sPos(d.x); }) 
                         .attr("cy", function(d) { return sPos(d.y); }) 
                         .attr("r", beadSize) 
                         .attr("fill", function(d) { return color(d.type); });
    }

   function getUpdateCnt(jsonfile) {
       var request = new XMLHttpRequest();
       request.open("GET", jsonfile, false);
       request.send(null)
       var JSON_object = JSON.parse(request.responseText);
       return JSON_object.num_frames;
   }

   var update_cnt = getUpdateCnt('./meta.json');

   function replayFrames() {
     var framerate = parseInt(document.getElementById("replay_framerate").value);
     var cur_replay = 1;
     replay = true;
     
     // the timer function that steps through the frames
     let replayTimer = setTimeout(function showFrame(){
         var tmp = getNewData("_frames/state_"+cur_replay+".json");
         updateFrame(tmp);      
         cur_replay = cur_replay + framerate;
         if(cur_replay < update_cnt) {
             replayTimer = setTimeout(showFrame, frameDelay);
         } else {
           replay = false;
         } 
     }, 1);
     
   }

    data = getNewData("state.json");
    updateFrame(data);

    // ---------------------- web sockets ----------------------
    const socket = new WebSocket('ws://localhost:8079');

    socket.onmessage = function (evt) {
       if(!replay) {
         if(evt.data == "u") {
                var tmp = getNewData("state.json");
                updateFrame(tmp);
                update_cnt=update_cnt+1;
        } else {
           console.log("Warning: we recvd a command other than update: "+evt.data);
        }
      }
    }

    // ---------------------- /web sockets ----------------------

</script>
</body>
