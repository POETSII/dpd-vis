<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="d3-3d.js"></script>
<body>

<svg width="2000" height="2000"></svg>
<script>

    var filter_water = false;

    var data    = [], min = max = 0;
    var universe_scale = 2.0;
    var bead_scale = 1;
    //var origin  = [450, 520], startAngle = Math.PI/8, beta = startAngle;
    var origin  = [500, 1500], startAngle = 0, beta = 0;
    //var origin  = [450, 720], startAngle = 0, beta = startAngle;
    // var svg     = d3.select('svg').call(d3.drag().on('drag', dragged).on('start', dragStart).on('end', dragEnd)).append('g');
    var svg     = d3.select('svg');
    // var colour   = d3.scaleOrdinal(d3.schemeCategory10);
    // var rn      = function(min, max){ return Math.round(d3.randomUniform(min, max+1)()); };
    var mx, mouseX;
    var filter_list = []; // list of beads that we don't want shown

    function colour(beadType) {
        if (beadType == 0)
            return "#1f77b4";
        else if (beadType == 1)
            return "#ff7f0e";
        else if (beadType == 2)
            return "#2ca02c";
    }

    function getNewData(jsonfile) {
        p_pos = [];
        var request = new XMLHttpRequest();
        request.open("GET", jsonfile, false);
        request.send(null)
        var JSON_object = JSON.parse(request.responseText);
        var particles = JSON_object.beads;
        for(var i = 0; i<particles.length; i++) {
            if (particles[i].z < offset || particles[i].z > (offset + 1.0)) {
                continue;
            }
            p_pos.push({
               x: Math.round(particles[i].x * 100.0) - max,
               y: Math.round(particles[i].y * 100.0) - max,
               z: Math.round(particles[i].z * 100.0) - max,
               id: particles[i].id,
               type: particles[i].type
             });
        }
        return p_pos;
    }

    // beadFiltered(beadId) this returns true if the bead ID is in the filter list
    function beadFilter(bead_type){
      if (bead_type == 0) { // Is water
        return filter_water;
      }
      return false;
    }

    var _3d = d3._3d()
        .scale(1/universe_scale)
        .origin(origin)
        .rotateX(startAngle)
        .rotateY(startAngle)
        .primitiveType('POINTS');

    var zScale = 0

    // ---------------------- web sockets ----------------------
    const socket = new WebSocket('ws://localhost:8079');
    var offset = 0.0;
    socket.onmessage = function (event) {
        d = JSON.parse(event.data);
        filter_water = d.filter_water;
        offset = d.offset;
        state = getNewData(d.vol_side + "_frames/state_" + d.timestep + ".json");
        state3D = _3d(state);
        extentZ = d3.extent(state3D, function(d){ return d.rotated.z });
        zScale  = d3.scaleLinear().domain([extentZ[1]+10, extentZ[0]-10]).range([1, 8]);
        processData(state3D);
    }

    // ---------------------- /web sockets ----------------------

    function processData(data){

        var points = svg.selectAll('circle').data(data);

        points
            .enter()
            .append('circle')
            .merge(points)
            .attr('fill',   function(d, i){
                                           if(beadFilter(d.type)) {
                                             return "none";
                                            } else {
                                             return colour(d.type);
                                            }
                                           })
            .attr('opacity',   function(d, i){
                                           if(beadFilter(d.type)) {
                                             return 0;
                                            } else {
                                             return 1.0;
                                            }
                                           })
            .attr('stroke', function(d, i){
                                           if (beadFilter(d.type)) {
                                            return "none";
                                           } else {
                                            return d3.color(colour(d.type)).darker(0.5);
                                           }
                                          })
            .sort(function(a, b){    return d3.descending(a.rotated.z, b.rotated.z); })
            .attr('cx', function(d){ return d.projected.x; })
            .attr('cy', function(d){ return d.projected.y; })
            .attr('r' , function(d){ return 2.22*bead_scale*zScale(d.rotated.z);
                                 });

        points.exit().remove();
    }

    // processData(data3D);

</script>
</body>
